// prisma/schema.prisma
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

generator nestgraphql {
  provider              = "node node_modules/prisma-nestjs-graphql"
  output                = "../src/generated-nestjs-typegraphql"
  fields_Validator_from = "class-validator"
  emitSingle            = true
  emitBlocks            = ["models", "enums"]

  // for yarn monorepos
  // provider = "prisma-nestjs-graphql"
  // output = "./@generated/nestjs-type-graphql"
}

enum SessionStatus {
  ACTIVE
  COMPLETED
  TERMINATED
}

enum BreakType {
  SHORT
  LUNCH
  PRAYER
  OTHER
}

enum SegmentType {
  WORK
  BREAK
}

enum UserRole {
  USER
  ADMIN
}

model User {
  id            String    @id @default(auto()) @map("_id") @db.ObjectId
  email         String    @unique
  name          String
  password      String
  role          UserRole  @default(USER)
  avatarUrl     String?
  isOnline      Boolean   @default(false)
  currentStatus String?
  slackUserId   String?
  salaryINR     Int?
  compensationINR Int?
  sessions      Session[]
  breaks        Break[]
  workLogs      WorkLog[]
  archived      Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  taskSuggestions Task[] @relation("TaskSuggestedBy")
  taskAssignments Task[] @relation("TaskAssignedTo")
  taskApprovals Task[] @relation("TaskApprovedBy")
  workExceptions WorkException[] @relation("UserWorkExceptions")
  dailyOutputScores DailyOutputScore[] @relation("UserDailyOutputScores")
  assignedScores DailyOutputScore[] @relation("AssignedScores")
  stabilityIncidents StabilityIncident[] @relation("UserStabilityIncidents")
  reportedIncidents StabilityIncident[] @relation("ReportedStabilityIncidents")
  payoutSnapshots PayoutSnapshot[] @relation("UserPayoutSnapshots")
  syncedPayoutSnapshots PayoutSnapshot[] @relation("PayoutSnapshotsSyncedBy")
  expensesRelated Expense[] @relation("ExpenseEmployee")
  expensesApproved Expense[] @relation("ExpenseApprover")
  expensesCreated Expense[] @relation("ExpenseCreator")

  @@map("users")
}

model Session {
  id             String        @id @default(auto()) @map("_id") @db.ObjectId
  userId         String        @db.ObjectId
  user           User          @relation(fields: [userId], references: [id])
  startTime      DateTime      @default(now())
  endTime        DateTime?
  totalDuration  Int           @default(0)
  totalBreakTime Int           @default(0)
  status         SessionStatus @default(ACTIVE)
  projectId      String?       @db.ObjectId
  project        Project?      @relation("sessionProject", fields: [projectId], references: [id])
  breaks         Break[]
  workLogs       WorkLog[]
  segments       Segment[]
  completedTasks Task[]        @relation("TaskCompletedInSession")
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@map("sessions")
}

model Project {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  slug      String    @unique
  segments  Segment[]
  isActive  Boolean   @default(true)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  sessions  Session[] @relation("sessionProject")
  workLogs  WorkLog[] @relation("workLogProject")
  tasks     Task[] @relation("projectTasks")

  @@map("projects")
}

model Break {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  userId    String    @db.ObjectId
  user      User      @relation(fields: [userId], references: [id])
  sessionId String    @db.ObjectId
  session   Session   @relation(fields: [sessionId], references: [id])
  type      BreakType
  startTime DateTime  @default(now())
  endTime   DateTime?
  duration  Int       @default(0)
  segments  Segment[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@map("breaks")
}

model WorkLog {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  user      User     @relation(fields: [userId], references: [id])
  sessionId String   @db.ObjectId
  session   Session  @relation(fields: [sessionId], references: [id])
  projectId String   @db.ObjectId
  project   Project  @relation("workLogProject", fields: [projectId], references: [id])
  content   String
  links     String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("work_logs")
}

model Segment {
  id        String      @id @default(auto()) @map("_id") @db.ObjectId
  sessionId String      @db.ObjectId
  session   Session     @relation(fields: [sessionId], references: [id])
  type      SegmentType
  projectId String?     @db.ObjectId
  project   Project?    @relation(fields: [projectId], references: [id])
  breakId   String?     @db.ObjectId
  break     Break?      @relation(fields: [breakId], references: [id])
  startTime DateTime    @default(now())
  endTime   DateTime?
  duration  Int         @default(0)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@map("segments")
}

enum TaskStatus {
  SUGGESTED
  APPROVED
  IN_PROGRESS
  COMPLETED
  PARTIALLY_COMPLETED
  ABANDONED
  REJECTED
  BLOCKED
}

enum TaskCategory {
  MOBILE_APP
  WEB_FRONTEND
  BACKEND_API
  FULL_STACK
  BUG_FIX
  DEBUGGING
  CODE_REVIEW
  TESTING_QA
  DEVOPS
  DOCUMENTATION
  CLIENT_COMMUNICATION
  MENTORING
  RESEARCH
  OFFICE_TASKS
  MISCELLANEOUS
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ExceptionType {
  FULL_DAY_LEAVE
  HALF_DAY_LEAVE
  LATE_ARRIVAL
  EARLY_EXIT
  WORK_FROM_HOME
  SICK_LEAVE
  EMERGENCY_LEAVE
  UNAUTHORIZED_ABSENCE
}

enum IncidentSeverity {
  CRITICAL
  HIGH
  MEDIUM
  LOW
  NEGLIGIBLE
}

enum IncidentType {
  PRODUCTION_BUG
  SECURITY_VULNERABILITY
  PERFORMANCE_ISSUE
  DATA_CORRUPTION
  DEPLOYMENT_FAILURE
  BREAKING_CHANGE
  TEST_FAILURE
  CODE_QUALITY_ISSUE
  HOTFIX_REQUIRED
  REGRESSION
}

enum ExpenseType {
  COMPANY_EXPENSE
  REIMBURSEMENT
  EMPLOYEE_BENEFIT
}

enum ExpenseCategory {
  OFFICE_SUPPLIES
  EQUIPMENT
  SOFTWARE_LICENSES
  TRAVEL
  MEALS_ENTERTAINMENT
  UTILITIES
  INTERNET_PHONE
  RENT
  MARKETING
  PROFESSIONAL_SERVICES
  EMPLOYEE_PERKS
  MISCELLANEOUS
}

enum ReimbursementStatus {
  PENDING
  APPROVED
  PAID
  REJECTED
  NOT_APPLICABLE
}


model WorkException {
  id            String        @id @default(auto()) @map("_id") @db.ObjectId
  userId        String        @db.ObjectId
  user          User          @relation("UserWorkExceptions", fields: [userId], references: [id])

  type          ExceptionType
  date          DateTime      // The date this happened

  // Only for late arrival / early exit (deprecated - use epoch versions)
  scheduledTime DateTime?
  actualTime    DateTime?

  // New epoch-based time fields (in seconds)
  scheduledTimeEpoch Int?
  actualTimeEpoch    Int?

  reason        String?
  notes         String?       // Admin notes if needed

  // Compensation tracking - the date the employee worked instead
  compensationDate DateTime?   // When the employee worked to compensate for this exception

  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@map("work_exceptions")
}


model Task {
  id          String       @id @default(auto()) @map("_id") @db.ObjectId
  title       String
  description String
  category    TaskCategory
  priority    TaskPriority @default(MEDIUM)
  status      TaskStatus   @default(SUGGESTED)
  
  // Performance Metrics
  points              Int
  suggestedPoints     Int? // What the developer suggested
  estimatedHours      Float
  actualHours         Float?
  
  // People
  suggestedById       String?  @db.ObjectId
  suggestedBy         User?    @relation("TaskSuggestedBy", fields: [suggestedById], references: [id])
  assignedToId        String?  @db.ObjectId
  assignedTo          User?    @relation("TaskAssignedTo", fields: [assignedToId], references: [id])
  approvedById        String?  @db.ObjectId
  approvedBy          User?    @relation("TaskApprovedBy", fields: [approvedById], references: [id])
  
  // Dates
  suggestedDate       DateTime @default(now())
  approvedDate        DateTime?
  startedDate         DateTime?
  completedDate       DateTime?
  dueDate             DateTime?

  // Completion tracking - for daily output score
  completedSessionId  String?  @db.ObjectId
  completedSession    Session? @relation("TaskCompletedInSession", fields: [completedSessionId], references: [id])
  score               Int?     // Admin-assigned score for task quality (0-200, null = not yet scored)

  // Evidence & Quality
  prLinks             String[]
  commitLinks         String[]
  screenshots         String[]

  // Production Bug Tracking
  causedProductionBug Boolean  @default(false)
  productionBugPenalty Int     @default(0)
  relatedBugTaskId    String?  @db.ObjectId // If this task is fixing a production bug

  // Admin Control
  rejectionReason     String?
  adminNotes          String?

  // Relations
  projectId           String?  @db.ObjectId
  project             Project? @relation("projectTasks", fields: [projectId], references: [id])
  stabilityIncidents  StabilityIncident[] @relation("TaskStabilityIncidents")
  incidentResolutions StabilityIncident[] @relation("IncidentResolutionTasks")

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // @@map("tasks")
}

// Daily Output Score - Admin assigns a score (0-10) for each user each day
model DailyOutputScore {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId

  // User being scored
  userId      String   @db.ObjectId
  user        User     @relation("UserDailyOutputScores", fields: [userId], references: [id])

  // The date for this score (stored as start of day UTC)
  date        DateTime

  // Performance score (0-10)
  score       Float

  // Breakdown of scoring factors
  tasksCompleted      Int      @default(0)
  taskDifficulty      Float?   // Average difficulty of tasks completed
  initiativeCount     Int      @default(0) // Count of self-suggested tasks
  qualityRating       Float?   // Admin's quality assessment (0-10)
  availabilityRating  Float?   // Admin's availability assessment (0-10)

  // Admin notes/feedback
  notes       String?

  // Who assigned this score
  assignedById String?  @db.ObjectId
  assignedBy   User?    @relation("AssignedScores", fields: [assignedById], references: [id])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, date])
  @@map("daily_output_scores")
}

model StabilityIncident {
  id                String            @id @default(auto()) @map("_id") @db.ObjectId

  // User who caused the incident
  userId            String            @db.ObjectId
  user              User              @relation("UserStabilityIncidents", fields: [userId], references: [id])

  // Incident Details
  type              IncidentType
  severity          IncidentSeverity
  title             String
  description       String

  // Related Task (optional - the task where this originated)
  taskId            String?           @db.ObjectId
  task              Task?             @relation("TaskStabilityIncidents", fields: [taskId], references: [id])

  // Resolution
  resolvedAt        Int?              // Epoch timestamp in seconds when resolved
  resolutionNotes   String?           // How it was resolved
  resolutionTaskId  String?           @db.ObjectId
  resolutionTask    Task?             @relation("IncidentResolutionTasks", fields: [resolutionTaskId], references: [id])

  // Root Cause Analysis
  rootCause         String?
  preventionPlan    String?

  // Incident Date (when it occurred/was discovered) - epoch timestamp in seconds
  incidentDate      Int

  // Who reported/logged this incident
  reportedById      String?           @db.ObjectId
  reportedBy        User?             @relation("ReportedStabilityIncidents", fields: [reportedById], references: [id])

  // Admin notes
  adminNotes        String?

  // Evidence
  screenshots       String[]
  logLinks          String[]

  // Metadata
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  @@map("stability_incidents")
}

model PayoutSnapshot {
  id                   String   @id @default(auto()) @map("_id") @db.ObjectId
  userId               String   @db.ObjectId
  user                 User     @relation("UserPayoutSnapshots", fields: [userId], references: [id])

  // Billing cycle dates (stored as ISO DateTime)
  billingCycleStart    DateTime
  billingCycleEnd      DateTime

  // Frozen scores at snapshot time
  monthlyOutputScore   Float
  availabilityScore    Float
  stabilityScore       Float

  // Frozen compensation values
  baseCompensationINR  Float
  expectedPayoutINR    Float
  differenceINR        Float    // expectedPayout - baseCompensation

  // Working days calculated at snapshot time
  workingDaysInCycle   Int

  // Audit metadata
  snapshotDate         DateTime  @default(now())
  syncedById           String?   @db.ObjectId
  syncedBy             User?     @relation("PayoutSnapshotsSyncedBy", fields: [syncedById], references: [id], onDelete: SetNull, onUpdate: Cascade)

  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  // Ensure one snapshot per user per billing cycle
  @@unique([userId, billingCycleStart, billingCycleEnd])
  @@index([billingCycleStart, billingCycleEnd])
  @@map("payout_snapshots")
}

model Expense {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId

  // Basic Info
  expenseType         ExpenseType
  category            ExpenseCategory
  amount              Float
  currency            String              @default("INR")
  description         String
  expenseDate         Int                 // Epoch seconds

  // Employee Association
  // Used for both reimbursements AND employee benefits
  relatedEmployeeId   String?             @db.ObjectId
  relatedEmployee     User?               @relation("ExpenseEmployee", fields: [relatedEmployeeId], references: [id])

  // Reimbursement Info (only for REIMBURSEMENT type)
  reimbursementStatus ReimbursementStatus @default(NOT_APPLICABLE)
  reimbursedDate      Int?                // Epoch seconds when reimbursement was paid

  // Documentation
  receiptUrl          String?
  invoiceNumber       String?
  vendor              String?

  // Approval
  approvedById        String?             @db.ObjectId
  approvedBy          User?               @relation("ExpenseApprover", fields: [approvedById], references: [id])
  approvedDate        Int?                // Epoch seconds

  // Metadata
  notes               String?
  createdById         String              @db.ObjectId
  createdBy           User                @relation("ExpenseCreator", fields: [createdById], references: [id])
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  @@map("expenses")
}